[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "1_models/pendulum.html",
    "href": "1_models/pendulum.html",
    "title": "Pendulum Model",
    "section": "",
    "text": "So in my quest to recover some experience from my uni days, I’m building up to a custom implementation of SLAM from first principles. First thing’s first, everybody’s favorite control system, the pendulum!\nWe know the model of the pendulum to be: \\[\\frac{d^2\\theta}{dt^2}+\\frac{g}{\\ell}\\sin{\\theta} = 0\\]\n\n# %matplotlib ipympl\nimport numpy as np\nimport scipy.integrate as spi\nimport matplotlib.pyplot as plt\n%matplotlib inline\nimport matplotlib as mpl\nmpl.rcParams['figure.dpi'] = 150\n\ng = 9.81\nl = 1.0\ntheta_0 = np.zeros(2)\n\n\ndef f(x, t0, params):\n    g, l = params['g'], params['l']\n    theta, dtheta = x[0], x[1]\n    ddtheta = - (g / l) * np.sin(theta)\n    return np.array([dtheta, ddtheta])\n\n\nfig, ax = plt.subplots(1, 1, figsize=(8, 2))\nt = np.linspace(0., 3., 30)\ntheta = spi.odeint(f, theta_0, t, args=({\"g\": g, \"l\": l},))\nax.plot(t, theta[:, 0], 'o-', label='$\\\\theta$')\nax.plot(t, theta[:, 1], '-', label='$\\\\dot{\\\\theta}$')\nax.legend()\n\n\n\n\n\n\n\n\nWell, that’s pretty boring. Let’s try some more exciting initial conditions, such as: \\[\\begin{bmatrix}\n\\theta \\\\ \\dot{\\theta}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\pi/2 \\\\ 0\n\\end{bmatrix}\n\\]\n\ntheta_0 = np.array([np.pi/2, 0])\nfig, ax = plt.subplots(1, 1, figsize=(8, 2))\nt = np.linspace(0., 10., 100)\ntheta = spi.odeint(f, theta_0, t, args=({\"g\": g, \"l\": l},))\nax.plot(t, theta[:, 0], 'o-', label='$\\\\theta$')\nax.plot(t, theta[:, 1], '-', label='$\\\\dot{\\\\theta}$')\nax.legend()\n\n\n\n\n\n\n\n\nMuch better! Now, we can use some movie magic (ahem LLMs) and try to create an animation based on this. I got Gemini to generate the following code:\n\nfrom matplotlib.animation import FuncAnimation\n\ndef animate_pendulum(t, states, params):\n    \"\"\"\n    Animates a simple pendulum.\n    \n    Parameters:\n    t      : array of time steps\n    states : array of state vectors [[theta1, dtheta1], [theta2, dtheta2], ...]\n    l      : length of the pendulum arm\n    \"\"\"\n    # 1. Convert angles to Cartesian coordinates\n    theta = states[:, 0]\n    l = params['l']\n    x = l * np.sin(theta)\n    y = -l * np.cos(theta)  # Negative because it hangs down from (0,0)\n\n    # 2. Set up the figure and axis\n    fig, ax = plt.subplots(figsize=(5, 5))\n    ax.set_xlim(-l * 1.2, l * 1.2)\n    ax.set_ylim(-l * 1.2, l * 1.2)\n    ax.set_aspect('equal')\n    ax.grid(True, linestyle='--')\n    \n    # 3. Create the visual elements\n    # The rod (line), the bob (large circle marker), and the trace (faded line)\n    line, = ax.plot([], [], 'o-', lw=2, color='#2c3e50', markersize=10, markerfacecolor='#e74c3c')\n    trace, = ax.plot([], [], '-', lw=1, color='#e74c3c', alpha=0.3)\n    \n    # 4. Initialization function for the animation\n    def init():\n        line.set_data([], [])\n        trace.set_data([], [])\n        return line, trace\n\n    # 5. Animation update function\n    def update(i):\n        # Update the rod and bob position\n        this_x = [0, x[i]]\n        this_y = [0, y[i]]\n        line.set_data(this_x, this_y)\n        \n        # Update the trace (showing previous positions)\n        trace.set_data(x[:i], y[:i])\n        return line, trace\n\n    # 6. Create the animation\n    # interval is the delay between frames in milliseconds\n    # blit=True makes the animation run faster by only redrawing changed parts\n    ani = FuncAnimation(fig, update, frames=len(t), init_func=init, \n                        blit=True, interval=(t[1]-t[0])*1000)\n\n    plt.title(\"Pendulum Simulation\")\n    plt.xlabel(\"X (m)\")\n    plt.ylabel(\"Y (m)\")\n    \n    return ani\n\nWe can now simulate a quick animation of the pendulum:\n\n%matplotlib widget\n\ntheta_0 = np.array([np.pi/2 * 1.1, 0])\nt = np.linspace(0., 10., 100)\ntheta = spi.odeint(f, theta_0, t, args=({\"g\": g, \"l\": l},))\n\nanimation = animate_pendulum(t, theta, {\"l\": l})\nplt.show()\n\n\n\n\nI now want to check the effect of initial conditions on the evolution of the system at the different equilibrium points. Intuitively we can locate these points at the downwards and upwards positions, but we can also quickly determine these points by setting the derivative to zero (I will now use \\(x\\) to refer to the state vector \\((\\theta, \\dot{\\theta})\\)):\n\\[ \\dot{x} = 0 \\rightarrow \\begin{bmatrix}\\dot{\\theta} \\\\ \\ddot{\\theta}  \\end{bmatrix} = \\begin{bmatrix}0\\\\ 0  \\end{bmatrix}  = \\begin{bmatrix}\\dot{\\theta} \\\\  -\\frac{g}{\\ell}\\sin{\\theta} \\end{bmatrix}\\]\nFrom the first equation, the angular velocity must be 0. From the second equation, we obtain the following relation: \\[ \\sin{\\theta} = 0 \\rightarrow \\; \\theta_{eq} = n\\pi,\\; n = 0, 1, 2, ...\\]\nWe therefore know we’ll find these equilibrium points at any multiple of \\(\\pi\\). In this case, we only care for what’s in the interval \\([0,2\\pi]\\), so we study the first two equilibrium points, \\(0\\) and \\(\\pi\\). Using the Jacobian we can determine the type of stability of the equilibrium points. If: - All the eigenvalues of the Jacobian have negative real parts \\(\\mathrm{Re}(\\lambda_i) &lt; 0\\), the system is asymptotically stable. - Any of the eigenvalues of the Jacobian have a positive real part, the system is unstable.\nFor our purposes, it is pretty evident that the equilibrium point \\([0, 0]\\) is stable, whereas the equilibrium point \\([\\pi, 0]\\) is unstable. We can try plotting the results of starting the system in this unstable equilibrium point, as well as slightly shifted away from it (around 0.11 radians or 0.6 degrees)\n\nfig, ax = plt.subplots(1, 1, figsize=(8, 2))\nt = np.linspace(0., 8., 100)\n# Unstable point (hope that pi is represented well enough with floating point)\ntheta_0 = np.array([np.pi, 0])\ntheta_unstable = spi.odeint(f, theta_0, t, args=({\"g\": g, \"l\": l},))\n# Unstable point + eps\ntheta_0 = np.array([3.13, 0])\ntheta_unstable_plus_eps = spi.odeint(f, theta_0, t, args=({\"g\": g, \"l\": l},))\n# Plot\nax.plot(t, theta_unstable[:, 0], '-', label='$\\\\theta$ (starting at $\\\\theta_0 = \\\\pi$)')\nax.plot(t, theta_unstable[:, 1], '-', label='$\\\\dot{\\\\theta}$ (starting at $\\\\theta_0 = \\\\pi$)')\nax.plot(t, theta_unstable_plus_eps[:, 0], '-', label='$\\\\theta$ (starting at $\\\\theta_0 = 3.13$)')\nax.plot(t, theta_unstable_plus_eps[:, 1], '-', label='$\\\\dot{\\\\theta}$ (starting at $\\\\theta_0 = 3.13$)')\nax.legend()\n\n\n\n\nThe last plot shows pretty evidently the effects of the unstable equilibrium point. By starting just 0.6 degrees away from the equilibrium point, we’ve managed to make the pendulum start swinging as it typically does. This wraps it up for today! In the next post, I’ll talk about linearizing this system and we can try controlling it."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "slam",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  }
]